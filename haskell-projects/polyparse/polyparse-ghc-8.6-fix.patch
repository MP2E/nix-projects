diff -Naur polyparse-1.12/src/Text/ParserCombinators/HuttonMeijer.hs polyparse-1.12-src/src/Text/ParserCombinators/HuttonMeijer.hs
--- polyparse-1.12/src/Text/ParserCombinators/HuttonMeijer.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/HuttonMeijer.hs	2018-09-28 07:54:05.259018242 -0700
@@ -37,6 +37,7 @@
 import Data.Char
 import Control.Applicative ( Applicative(pure,(<*>)), Alternative(empty,(<|>)) )
 import Control.Monad
+import qualified Control.Monad.Fail as Fail
 
 infixr 5 +++
 
@@ -62,6 +63,7 @@
    -- >>=         :: Parser a -> (a -> Parser b) -> Parser b
    (P p) >>= f     = P (\inp -> concat [papply (f v) out | (v,out) <- p inp])
 
+instance Fail.MonadFail Parser where
    -- fail        :: String -> Parser a
    fail _          = P (\_ -> [])
 
diff -Naur polyparse-1.12/src/Text/ParserCombinators/HuttonMeijerWallace.hs polyparse-1.12-src/src/Text/ParserCombinators/HuttonMeijerWallace.hs
--- polyparse-1.12/src/Text/ParserCombinators/HuttonMeijerWallace.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/HuttonMeijerWallace.hs	2018-09-28 07:54:33.358968967 -0700
@@ -56,6 +56,7 @@
 import Data.Char
 import Control.Applicative ( Applicative(pure,(<*>)), Alternative(empty,(<|>)) )
 import Control.Monad
+import qualified Control.Monad.Fail as Fail
 
 infixr 5 +++
 
@@ -88,6 +89,7 @@
                             [ papply' (f v) s out | (v,s,out) <- res ]
                         Left err  -> Left err
                        )
+instance Fail.MonadFail (Parser s t e) where
    -- fail        :: String -> Parser s t e a
    fail err        = P (\st inp -> Right [])
   -- I know it's counterintuitive, but we want no-parse, not an error.
diff -Naur polyparse-1.12/src/Text/ParserCombinators/Poly/ByteStringChar.hs polyparse-1.12-src/src/Text/ParserCombinators/Poly/ByteStringChar.hs
--- polyparse-1.12/src/Text/ParserCombinators/Poly/ByteStringChar.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/Poly/ByteStringChar.hs	2018-09-28 07:59:34.473445399 -0700
@@ -23,6 +23,7 @@
 import qualified Data.ByteString.Lazy.Char8 as BS
 import Data.ByteString.Lazy.Char8 (ByteString)
 import Control.Applicative
+import qualified Control.Monad.Fail as Fail
 
 -- | This @Parser@ datatype is a specialised parsing monad with error
 --   reporting.  Whereas the standard version can be used for arbitrary
@@ -38,13 +39,15 @@
 
 instance Monad Parser where
     return x     = P (\ts-> Success ts x)
-    fail e       = P (\ts-> Failure ts e)
     (P f) >>= g  = P (continue . f)
       where
         continue (Success ts x)             = let (P g') = g x in g' ts
         continue (Committed r)              = Committed (continue r)
         continue (Failure ts e)             = Failure ts e
 
+instance Fail.MonadFail Parser where
+    fail e       = P (\ts-> Failure ts e)
+
 instance Commitment Parser where
     commit (P p)         = P (Committed . squash . p)
       where
diff -Naur polyparse-1.12/src/Text/ParserCombinators/Poly/ByteString.hs polyparse-1.12-src/src/Text/ParserCombinators/Poly/ByteString.hs
--- polyparse-1.12/src/Text/ParserCombinators/Poly/ByteString.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/Poly/ByteString.hs	2018-09-28 07:56:21.265780481 -0700
@@ -23,6 +23,7 @@
 import qualified Data.ByteString.Lazy as BS
 import Data.ByteString.Lazy (ByteString)
 import Control.Applicative
+import qualified Control.Monad.Fail as Fail
 import Data.Word
 
 -- | This @Parser@ datatype is a specialised parsing monad with error
@@ -39,13 +40,15 @@
 
 instance Monad Parser where
     return x     = P (\ts-> Success ts x)
-    fail e       = P (\ts-> Failure ts e)
     (P f) >>= g  = P (continue . f)
       where
         continue (Success ts x)             = let (P g') = g x in g' ts
         continue (Committed r)              = Committed (continue r)
         continue (Failure ts e)             = Failure ts e
 
+instance Fail.MonadFail Parser where
+    fail e       = P (\ts-> Failure ts e)
+
 instance Commitment Parser where
     commit (P p)         = P (Committed . squash . p)
       where
diff -Naur polyparse-1.12/src/Text/ParserCombinators/Poly/Lazy.hs polyparse-1.12-src/src/Text/ParserCombinators/Poly/Lazy.hs
--- polyparse-1.12/src/Text/ParserCombinators/Poly/Lazy.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/Poly/Lazy.hs	2018-09-28 07:55:14.350897230 -0700
@@ -22,6 +22,7 @@
 import Text.ParserCombinators.Poly.Result
 import qualified Text.ParserCombinators.Poly.Parser as P
 import Control.Applicative
+import qualified Control.Monad.Fail as Fail
 
 #if __GLASGOW_HASKELL__
 import Control.Exception hiding (bracket)
@@ -38,7 +39,7 @@
 --   to have a different instance.
 newtype Parser t a = P (P.Parser t a)
 #ifdef __GLASGOW_HASKELL__
-        deriving (Functor,Monad,Commitment)
+        deriving (Functor,Monad,Fail.MonadFail,Commitment)
 #else
 instance Functor (Parser t) where
     fmap f (P p) = P (fmap f p)
diff -Naur polyparse-1.12/src/Text/ParserCombinators/Poly/Lex.hs polyparse-1.12-src/src/Text/ParserCombinators/Poly/Lex.hs
--- polyparse-1.12/src/Text/ParserCombinators/Poly/Lex.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/Poly/Lex.hs	2018-09-28 07:58:44.068532558 -0700
@@ -30,6 +30,7 @@
 import Text.ParserCombinators.Poly.Base
 import Text.ParserCombinators.Poly.Result
 import Control.Applicative
+import qualified Control.Monad.Fail as Fail
 
 -- | In a strict language, where creating the entire input list of tokens
 --   in one shot may be infeasible, we can use a lazy "callback" kind of
@@ -55,13 +56,15 @@
 
 instance Monad (Parser t) where
     return x     = P (\ts-> Success ts x)
-    fail e       = P (\ts-> Failure ts e)
     (P f) >>= g  = P (continue . f)
       where
         continue (Success ts x)             = let (P g') = g x in g' ts
         continue (Committed r)              = Committed (continue r)
         continue (Failure ts e)             = Failure ts e
 
+instance Fail.MonadFail (Parser t) where
+    fail e       = P (\ts-> Failure ts e)
+
 instance Commitment (Parser t) where
     commit (P p)         = P (Committed . squash . p)
       where
diff -Naur polyparse-1.12/src/Text/ParserCombinators/Poly/Parser.hs polyparse-1.12-src/src/Text/ParserCombinators/Poly/Parser.hs
--- polyparse-1.12/src/Text/ParserCombinators/Poly/Parser.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/Poly/Parser.hs	2018-09-28 07:56:08.697802376 -0700
@@ -20,6 +20,7 @@
 import Text.ParserCombinators.Poly.Base
 import Text.ParserCombinators.Poly.Result
 import Control.Applicative
+import qualified Control.Monad.Fail as Fail
 
 -- | This @Parser@ datatype is a fairly generic parsing monad with error
 --   reporting.  It can be used for arbitrary token types, not just
@@ -39,13 +40,15 @@
 
 instance Monad (Parser t) where
     return x     = P (\ts-> Success ts x)
-    fail e       = P (\ts-> Failure ts e)
     (P f) >>= g  = P (continue . f)
       where
         continue (Success ts x)             = let (P g') = g x in g' ts
         continue (Committed r)              = Committed (continue r)
         continue (Failure ts e)             = Failure ts e
 
+instance Fail.MonadFail (Parser t) where
+    fail e       = P (\ts-> Failure ts e)
+
 instance Alternative (Parser t) where
     empty     = fail "no parse"
     p <|> q   = p `onFail` q
diff -Naur polyparse-1.12/src/Text/ParserCombinators/Poly/StateLazy.hs polyparse-1.12-src/src/Text/ParserCombinators/Poly/StateLazy.hs
--- polyparse-1.12/src/Text/ParserCombinators/Poly/StateLazy.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/Poly/StateLazy.hs	2018-09-28 07:56:54.005723501 -0700
@@ -26,6 +26,7 @@
 import Text.ParserCombinators.Poly.Result
 import qualified Text.ParserCombinators.Poly.StateParser as P
 import Control.Applicative
+import qualified Control.Monad.Fail as Fail
 
 #if __GLASGOW_HASKELL__
 import Control.Exception hiding (bracket)
@@ -42,7 +43,7 @@
 --   to have a different instance.
 newtype Parser s t a = P (P.Parser s t a)
 #ifdef __GLASGOW_HASKELL__
-        deriving (Functor,Monad,Commitment)
+        deriving (Functor,Monad,Fail.MonadFail,Commitment)
 #else
 instance Functor (Parser s t) where
     fmap f (P p) = P (fmap f p)
diff -Naur polyparse-1.12/src/Text/ParserCombinators/Poly/StateParser.hs polyparse-1.12-src/src/Text/ParserCombinators/Poly/StateParser.hs
--- polyparse-1.12/src/Text/ParserCombinators/Poly/StateParser.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/Poly/StateParser.hs	2018-09-28 07:58:12.321587545 -0700
@@ -23,6 +23,7 @@
 import Text.ParserCombinators.Poly.Base
 import Text.ParserCombinators.Poly.Result
 import Control.Applicative
+import qualified Control.Monad.Fail as Fail
 
 -- | This @Parser@ datatype is a fairly generic parsing monad with error
 --   reporting, and running state.
@@ -42,13 +43,15 @@
 
 instance Monad (Parser s t) where
     return x     = P (\s ts-> Success (ts,s) x)
-    fail e       = P (\s ts-> Failure (ts,s) e)
     (P f) >>= g  = P (\s-> continue . f s)
       where
         continue (Success (ts,s) x)        = let (P g') = g x in g' s ts
         continue (Committed r)             = Committed (continue r)
         continue (Failure tss e)           = Failure tss e
 
+instance Fail.MonadFail (Parser s t) where
+    fail e       = P (\s ts-> Failure (ts,s) e)
+
 instance Alternative (Parser s t) where
     empty     = fail "no parse"
     p <|> q   = p `onFail` q
diff -Naur polyparse-1.12/src/Text/ParserCombinators/Poly/StateText.hs polyparse-1.12-src/src/Text/ParserCombinators/Poly/StateText.hs
--- polyparse-1.12/src/Text/ParserCombinators/Poly/StateText.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/Poly/StateText.hs	2018-09-28 07:57:41.533640935 -0700
@@ -28,6 +28,7 @@
 import qualified Data.Text.Lazy as T
 import Data.Text.Lazy (Text)
 import Control.Applicative
+import qualified Control.Monad.Fail as Fail
 
 -- | This @Parser@ datatype is a specialised parsing monad with error
 --   reporting.  Whereas the standard version can be used for arbitrary
@@ -45,13 +46,15 @@
 
 instance Monad (Parser s) where
     return x     = P (\s ts-> Success (ts,s) x)
-    fail e       = P (\s ts-> Failure (ts,s) e)
     (P f) >>= g  = P (\s-> continue . f s)
       where
         continue (Success (ts,s) x)         = let (P g') = g x in g' s ts
         continue (Committed r)              = Committed (continue r)
         continue (Failure ts e)             = Failure ts e
 
+instance Fail.MonadFail (Parser s) where
+    fail e       = P (\s ts-> Failure (ts,s) e)
+
 instance Commitment (Parser s) where
     commit (P p)         = P (\s-> Committed . squash . p s)
       where
diff -Naur polyparse-1.12/src/Text/ParserCombinators/Poly/Text.hs polyparse-1.12-src/src/Text/ParserCombinators/Poly/Text.hs
--- polyparse-1.12/src/Text/ParserCombinators/Poly/Text.hs	2016-04-12 10:10:33.000000000 -0700
+++ polyparse-1.12-src/src/Text/ParserCombinators/Poly/Text.hs	2018-09-28 07:59:10.469486890 -0700
@@ -24,6 +24,7 @@
 import qualified Data.Text.Lazy as T
 import Data.Text.Lazy (Text)
 import Control.Applicative
+import qualified Control.Monad.Fail as Fail
 
 -- | This @Parser@ datatype is a specialised parsing monad with error
 --   reporting.  Whereas the standard version can be used for arbitrary
@@ -39,13 +40,15 @@
 
 instance Monad Parser where
     return x     = P (\ts-> Success ts x)
-    fail e       = P (\ts-> Failure ts e)
     (P f) >>= g  = P (continue . f)
       where
         continue (Success ts x)             = let (P g') = g x in g' ts
         continue (Committed r)              = Committed (continue r)
         continue (Failure ts e)             = Failure ts e
 
+instance Fail.MonadFail Parser where
+    fail e       = P (\ts-> Failure ts e)
+
 instance Commitment Parser where
     commit (P p)         = P (Committed . squash . p)
       where
